{"componentChunkName":"component---src-templates-blog-post-js","path":"/writings/testable-code/","result":{"data":{"site":{"siteMetadata":{"title":"KWGUO Blog"}},"markdownRemark":{"id":"11a8aee8-284e-50ec-8bab-dd4968522eca","excerpt":"我想要寫這篇想了一陣子，最近看到 COSCUP 有個演講正好講出我心裡所想的，決定在這邊紀錄一下，順帶一提影片是 談談 go 測試的二三事 SOLID 大家都知道 SOLID 指的是下面這五個原則，就我的經驗來看，有三個原則對於測試來說是最為重要的，就是 SRP & ISP & DIP。 Single…","html":"<p>我想要寫這篇想了一陣子，最近看到 COSCUP 有個演講正好講出我心裡所想的，決定在這邊紀錄一下，順帶一提影片是 <a href=\"https://www.youtube.com/watch?v=4rxMPYZdyHo&#x26;list=PLqfib4St70XPWjZqmkE2auXM50140lgut&#x26;index=58\">談談 go 測試的二三事</a></p>\n<h2>SOLID</h2>\n<p>大家都知道 SOLID 指的是下面這五個原則，就我的經驗來看，有三個原則對於測試來說是最為重要的，就是 SRP &#x26; ISP &#x26; DIP。</p>\n<ul>\n<li>Single Responsibility Principle (SRP) 單一職責原則</li>\n<li>Open-Closed Principle (OCP) 開放封閉原則</li>\n<li>Liskov Substitution Principle (LSP) 里氏替換原則</li>\n<li>Interface Segregation Principle (ISP) 介面隔離原則</li>\n<li>Dependency Inversion Principle(DIP) 依賴反轉原則</li>\n</ul>\n<h3>SRP</h3>\n<p>SRP 說一個類別只能做一件事情，在這個 functional programming 崛起的年代，前端提倡所謂的 pure function，也就是這個 function 只要輸入相同，就會得到相同的輸出，這樣的 function 更容易測試，我們來看一段程式。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// first case</span>\n<span class=\"token keyword\">const</span> successResults <span class=\"token operator\">=</span> task<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">it</span> <span class=\"token operator\">=></span> <span class=\"token operator\">!</span>it<span class=\"token punctuation\">.</span>error<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">it</span> <span class=\"token operator\">=></span> it<span class=\"token punctuation\">.</span>result<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// second case</span>\n<span class=\"token keyword\">const</span> successResults <span class=\"token operator\">=</span> task<span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">acc<span class=\"token punctuation\">,</span> it</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>it<span class=\"token punctuation\">.</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    acc<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>it<span class=\"token punctuation\">.</span>result<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> acc\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>我認為第一個比較好的原因是因為 function 只做一件事情，雖然兩個都是 pure function ，但是第一個相較於第二個更符合 SRP，如果要測試的話，第一個的測試也比較容易撰寫，而且也更不容易改動。</p>\n<h3>ISP</h3>\n<p><a href=\"https://youtu.be/4rxMPYZdyHo?list=PLqfib4St70XPWjZqmkE2auXM50140lgut&#x26;t=1453\">影片中</a>講到一個很重要的觀念，在寫測試的時候，我們時常需要去 mock 某個第三方物件，如果該物件的 interface 很大，那我們在 mock 的時候就要 mock 到死，但其實我們根本不用這麼多， golang 的 duck typing 在這方面給我們一個方便，假設我們有兩個 package A &#x26; B，A 需要 B 的一個 class 中的其中一個 function，我們可以在 A 中 建立一個 interface 只包含 該 function ，這樣當我們在測試的時候，我們不但可以止 mock 其中一個 function，也可以獨立測試 package A 而不需用依賴到其他 package。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">   package         package\n   uploader           s3\n+-----------+   +-----------+\n| S3Service |   | S3Object  |\n| + put()   |   | + put()   |\n| Uploader  |   | + get()   |\n|           |   |           |\n+-----------+   +-----------+</code></pre></div>\n<p>像上面的圖例，Uploader 依賴於 S3Service 而非 S3 Object，所以在測試的時候只需要 mock S3Service ，但使用上我們依然可以使用 S3Object，這種做法非常好用，但很容易沒注意到。</p>\n<h3>DIP</h3>\n<p>DIP 提倡一個非常重要的觀念，就是注入物件而非建立物件，當我們改用注入物件，就能夠輕鬆的改成使用 mock 的物件，離提升我們的可測性。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">struct</span> UserRepo <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">*</span>db DB\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">NewUserRepoWithDI</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>db DB<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> UserRepo<span class=\"token punctuation\">{</span>db<span class=\"token punctuation\">:</span> db<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">NewUserRepoWithoutDI</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  db <span class=\"token operator\">:=</span> <span class=\"token function\">NewDB</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> UserRepo<span class=\"token punctuation\">{</span>db<span class=\"token punctuation\">:</span> db<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>repo UserRepo<span class=\"token punctuation\">)</span> <span class=\"token function\">CreateUser</span><span class=\"token punctuation\">(</span>name <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  repo<span class=\"token punctuation\">.</span>db<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>User<span class=\"token punctuation\">{</span>name<span class=\"token punctuation\">:</span> name<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>如果我們使用 <code class=\"language-text\">NewUserRepoWithoutDI</code> ，那撰寫測試的難度就會提高許多，因為我們要讓 <code class=\"language-text\">NewDB</code> 回傳我們的 mock db，但如果使用 <code class=\"language-text\">NewUserRepoWithDI</code> ，那只要直接傳入我們的 mock db 就行了，難易度會大幅下降。</p>\n<p>另外使用 DIP 有個好處，那就是我們可以保證全域唯一性，過去我們要使用 singleton 來建立<strong>單有唯一</strong>的物件，但現在我們只要在 app launch 的時候建立好物件，之後把物件傳來傳去，也可以跟 singleton 一樣節省使用的 memory，當然如果要 lazy 就沒辦法了，但既然早晚要用到，那一開始就建立，其實沒有多大的差別，而且這麼做有個比 singleton 好的地方，是不需用每次讀取物件時都要檢查是否已經有了，並且可以避免掉 race condition，在效能上可以說是更加優秀。</p>\n<h2>References</h2>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=4rxMPYZdyHo&#x26;list=PLqfib4St70XPWjZqmkE2auXM50140lgut&#x26;index=58\">https://www.youtube.com/watch?v=4rxMPYZdyHo&#x26;list=PLqfib4St70XPWjZqmkE2auXM50140lgut&#x26;index=58</a></li>\n</ul>","frontmatter":{"title":"Testable code","tags":["writing","test","golang","code quality"],"date":"September 08, 2020","description":"How to write a testable code"}}},"pageContext":{"slug":"/testable-code/","previous":{"fields":{"slug":"/electron-mac-app-store-sign/"},"frontmatter":{"title":"Electron mac app store sign","tags":["writing","mac app store","mas","electron","sign","deployment"]}},"next":{"fields":{"slug":"/electron-mac-developer-id-sign/"},"frontmatter":{"title":"Electron mac developer id sign","tags":["writing","electron","sign","deployment","entitlement"]}}}},"staticQueryHashes":["4111554205","63159454"]}