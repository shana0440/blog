{"componentChunkName":"component---src-templates-blog-post-js","path":"/writings/flutter-performance-overview/","result":{"data":{"site":{"siteMetadata":{"title":"KWGUO Blog"}},"markdownRemark":{"id":"a2c167b8-572c-5ff8-9740-8b1f7d7ee8a7","excerpt":"簡單註記一下 Performance best practices 的內容，讓自己以後再開發的時候可以多注意一些。 Flutter 是 single thread，所以需要格外注意不要 block thread，不然整個 UI 都會掛掉，所以像是 open/read/write file…","html":"<p>簡單註記一下 <a href=\"https://flutter.dev/docs/perf/rendering/best-practices\">Performance best practices</a> 的內容，讓自己以後再開發的時候可以多注意一些。</p>\n<ol>\n<li>Flutter 是 single thread，所以需要格外注意不要 block thread，不然整個 UI 都會掛掉，所以像是 open/read/write file 之類的方法，都盡量使用 async 來處理。</li>\n<li>為了讓整個 UI 的運作是流暢的，所以必須要保持在 <strong>60fps</strong>，因此每次繪製畫面都需要在 <code class=\"language-text\">16ms (1000ms/60)</code> 內完成，維持在這個渲染時間下，也避免手機過熱，以及電量消耗過快的問題。</li>\n<li>不要再 <code class=\"language-text\">build()</code> 當中做任何昂貴的操作，像是開啟檔案什麼的，因為 <code class=\"language-text\">build()</code> 會經常被呼叫到，不論是在 <code class=\"language-text\">setState</code> 或者是當任一祖先 rebuild 的時候。</li>\n<li>盡量讓避免 <code class=\"language-text\">build()</code> 當中包含大量的元素，取而代之應該建立多個小 widget 各自維護自己的 state。</li>\n<li>由於 <code class=\"language-text\">setState</code> 會讓所有的 child widget rebuild，因此必須盡力避免在上層 widget 中呼叫 setState。</li>\n<li>盡量避免任何會觸發 <a href=\"https://api.flutter.dev/flutter/dart-ui/Canvas/saveLayer.html\"><code class=\"language-text\">saveLayer()</code></a> 的 widget 以及情況。 <code class=\"language-text\">saveLayer()</code> 會建立一個 stack 並把跟任何變化存在裡頭，最後攤平成一個圖層，由於他會請求一個 buffer 來處理這些部分，所以會特別的昂貴，是所有 operation 中最昂貴的一個。\n<ol>\n<li><code class=\"language-text\">Opacity</code> widget, 這個會觸發 <code class=\"language-text\">saveLayer()</code> 盡量使用 <code class=\"language-text\">FadeInImage</code> 或 <code class=\"language-text\">AnimatedOpacity</code> 代替。</li>\n<li><code class=\"language-text\">Clipping</code> with <code class=\"language-text\">Clip.antiAliasWithSaveLayer</code> (雖然一般情況下 <code class=\"language-text\">Clipping</code> 並不會呼叫到 <code class=\"language-text\">saveLayer()</code>，但是 <code class=\"language-text\">Clipping</code> 本身就是一個昂貴的操作，要注意使用)。</li>\n<li><a href=\"https://flutter.dev/docs/perf/rendering/best-practices#apply-effects-only-when-needed\">Apply effects only when needed</a> 網站上還有列出幾個我認為比較不常遇到的。</li>\n</ol>\n</li>\n<li>使用 <code class=\"language-text\">AnimatedBuilder</code> 的時候，要注意 <code class=\"language-text\">builder()</code> 內的 widget 會在每個 frame 都會 rebuild，除非是跟 animation 有關的 widget，例如 rotate/opacity，否則應該在 child 先 build 好，接著在 <code class=\"language-text\">builder()</code> 當中取得 child 在繪製。 <a href=\"%60https://api.flutter.dev/flutter/widgets/AnimatedBuilder-class.html#performance-optimizations%60\">Performance optimizations</a>。</li>\n<li>不要在 animation 中使用 clipping，最好先 clipping 之後在使用 animation。</li>\n<li>在沒有特殊需求（再不可見的情況下，還需要佔據空間/回應事件等）下，使用 <code class=\"language-text\">if (isDisplayWidget) Widget</code> 取代 <code class=\"language-text\">Visibility(child: Widget)</code>，可以節省 build cost。</li>\n<li>使用 <code class=\"language-text\">ListView.builder</code> 繪製大量 item</li>\n</ol>\n<p>以上是一些關於性能需要注意的事項，關於 <code class=\"language-text\">StatefulWidget</code> &#x26; <code class=\"language-text\">InheritedWidget</code> 的部分打算另外開文章來寫。</p>","frontmatter":{"title":"Flutter Performance Overview","tags":["writing","flutter","performance","render"],"date":"February 24, 2020","description":"The best practices of flutter rendering"}}},"pageContext":{"slug":"/flutter-performance-overview/","previous":null,"next":{"fields":{"slug":"/build-and-deploy-ios-app/"},"frontmatter":{"title":"Build and Deploy iOS app","tags":["writing","flutter","ios","deployment","app store","sign"]}}}},"staticQueryHashes":["4111554205","63159454"]}